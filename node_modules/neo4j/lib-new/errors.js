// Generated by CoffeeScript 1.8.0
(function() {
  var $, assert, http,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  $ = require('underscore');

  assert = require('assert');

  http = require('http');

  this.Error = (function(_super) {
    __extends(Error, _super);

    function Error(message, neo4j) {
      this.message = message != null ? message : 'Unknown error';
      this.neo4j = neo4j != null ? neo4j : {};
      this.name = 'neo4j.' + this.constructor.name;
      Error.captureStackTrace(this, this.constructor);
    }

    Error._fromResponse = function(resp) {
      var ErrorClass, ErrorType, body, error, headers, logBody, message, reqText, statusCode, statusText, _ref;
      body = resp.body, headers = resp.headers, statusCode = resp.statusCode;
      if (statusCode < 400) {
        return null;
      }
      if (body != null ? (_ref = body.errors) != null ? _ref.length : void 0 : void 0) {
        error = body.errors[0];
        return this._fromObject(error);
      }
      ErrorType = statusCode >= 500 ? 'Database' : 'Client';
      ErrorClass = exports["" + ErrorType + "Error"];
      message = "" + statusCode + " ";
      logBody = statusCode >= 500;
      if (body != null ? body.exception : void 0) {
        message += "[" + body.exception + "] " + (body.message || '(no message)');
      } else {
        statusText = http.STATUS_CODES[statusCode];
        reqText = "" + resp.req.method + " " + resp.req.path;
        message += "" + statusText + " response for " + reqText;
        logBody = true;
      }
      if (logBody && (body != null)) {
        message += ": " + (JSON.stringify(body, null, 4));
      }
      return new ErrorClass(message, body);
    };

    Error._fromObject = function(obj) {
      var ErrorClass, category, classification, code, fullMessage, message, neo, stackTrace, title, _ref;
      if ((obj.stacktrace != null) && (obj.stackTrace == null)) {
        obj.stackTrace = obj.stacktrace;
        delete obj.stacktrace;
      }
      code = obj.code, message = obj.message, stackTrace = obj.stackTrace;
      _ref = code.split('.'), neo = _ref[0], classification = _ref[1], category = _ref[2], title = _ref[3];
      ErrorClass = exports[classification];
      fullMessage = "[" + code + "] ";
      if (stackTrace && (classification === 'DatabaseError' || !message)) {
        if (message && (stackTrace.indexOf(message)) === -1) {
          stackTrace = "" + message + ": " + stackTrace;
        }
        stackTrace = stackTrace.replace(/\t/g, '    ').replace(/\n/g, '\n    ');
        fullMessage += stackTrace;
      } else {
        fullMessage += message;
      }
      return new ErrorClass(fullMessage, obj);
    };

    return Error;

  })(Error);

  this.ClientError = (function(_super) {
    __extends(ClientError, _super);

    function ClientError() {
      return ClientError.__super__.constructor.apply(this, arguments);
    }

    return ClientError;

  })(this.Error);

  this.DatabaseError = (function(_super) {
    __extends(DatabaseError, _super);

    function DatabaseError() {
      return DatabaseError.__super__.constructor.apply(this, arguments);
    }

    return DatabaseError;

  })(this.Error);

  this.TransientError = (function(_super) {
    __extends(TransientError, _super);

    function TransientError() {
      return TransientError.__super__.constructor.apply(this, arguments);
    }

    return TransientError;

  })(this.Error);

}).call(this);

//# sourceMappingURL=errors.js.map
