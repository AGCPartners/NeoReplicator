// Generated by CoffeeScript 1.8.0
(function() {
  var FAR_FUTURE_MS, Transaction, errors, utils;

  errors = require('./errors');

  utils = require('./utils');

  FAR_FUTURE_MS = Date.now() + 1000 * 60 * 60 * 24 * 365;

  module.exports = Transaction = (function() {
    var get;

    function Transaction(_db) {
      this._db = _db;
      this._id = null;
      this._expires = null;
      this._pending = false;
      this._committed = false;
      this._rolledBack = false;
    }

    get = function(props) {
      var getter, name, _results;
      _results = [];
      for (name in props) {
        getter = props[name];
        _results.push(Object.defineProperty(Transaction.prototype, name, {
          configurable: true,
          enumerable: true,
          get: getter
        }));
      }
      return _results;
    };

    get({
      STATE_OPEN: function() {
        return 'open';
      }
    });

    get({
      STATE_PENDING: function() {
        return 'pending';
      }
    });

    get({
      STATE_COMMITTED: function() {
        return 'committed';
      }
    });

    get({
      STATE_ROLLED_BACK: function() {
        return 'rolled back';
      }
    });

    get({
      STATE_EXPIRED: function() {
        return 'expired';
      }
    });

    get({
      expiresAt: function() {
        if (this._expires) {
          return new Date(this._expires);
        } else {
          return new Date(FAR_FUTURE_MS);
        }
      }
    });

    get({
      expiresIn: function() {
        if (this._expires) {
          return this.expiresAt - (new Date);
        } else {
          return Infinity;
        }
      }
    });

    get({
      state: function() {
        switch (false) {
          case !this._pending:
            return this.STATE_PENDING;
          case !this._committed:
            return this.STATE_COMMITTED;
          case !this._rolledBack:
            return this.STATE_ROLLED_BACK;
          case !(this.expiresIn <= 0):
            return this.STATE_EXPIRED;
          default:
            return this.STATE_OPEN;
        }
      }
    });

    Transaction.prototype.cypher = function(opts, cb) {
      var errMsg;
      if (opts == null) {
        opts = {};
      }
      errMsg = (function() {
        switch (this.state) {
          case this.STATE_PENDING:
            return 'A request within this transaction is currently in progress. Concurrent requests within a transaction are not allowed.';
          case this.STATE_EXPIRED:
            return 'This transaction has expired. You can get the expiration time of a transaction through its `expiresAt` (Date) and `expiresIn` (ms) properties. To prevent a transaction from expiring, execute any action or call `renew` before the transaction expires.';
          case this.STATE_COMMITTED:
            return 'This transaction has been committed. Transactions cannot be reused; begin a new one instead.';
          case this.STATE_ROLLED_BACK:
            return 'This transaction has been rolled back. Transactions get automatically rolled back on any DatabaseErrors, as well as any errors during a commit. That includes auto-commit queries (`{commit: true}`). Transactions cannot be reused; begin a new one instead.';
        }
      }).call(this);
      if (errMsg) {
        throw new errors.ClientError(errMsg);
      }
      this._pending = true;
      return this._db.cypher(opts, (function(_this) {
        return function(err, results) {
          _this._pending = false;
          if (_this._id) {
            return cb(err, results);
          }
          if (opts.commit && !err) {
            _this._committed = true;
          } else {
            _this._rolledBack = true;
          }
          return cb(err, results);
        };
      })(this), this);
    };

    Transaction.prototype.commit = function(cb) {
      return this.cypher({
        commit: true
      }, cb);
    };

    Transaction.prototype.rollback = function(cb) {
      return this.cypher({
        rollback: true
      }, cb);
    };

    Transaction.prototype.renew = function(cb) {
      return this.cypher({}, cb);
    };

    Transaction.prototype._updateFromResponse = function(resp) {
      var body, headers, statusCode, transaction, transactionURL;
      if (!resp) {
        throw new Error('Unexpected: no transactional response!');
      }
      body = resp.body, headers = resp.headers, statusCode = resp.statusCode;
      transaction = body.transaction;
      if (!transaction) {
        this._id = this._expires = null;
        return;
      }
      this._expires = new Date(transaction.expires);
      if (this._id) {
        return;
      }
      if (statusCode !== 201) {
        throw new Error('Unexpected: transaction returned by Neo4j, but it was never 201 Created, so we have no ID!');
      }
      if (!(transactionURL = headers['location'])) {
        throw new Error('Unexpected: transaction response is 201 Created, but with no Location header!');
      }
      return this._id = utils.parseId(transactionURL);
    };

    return Transaction;

  })();

}).call(this);

//# sourceMappingURL=Transaction.js.map
